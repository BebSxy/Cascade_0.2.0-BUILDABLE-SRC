/*
 * Decompiled with CFR 0.151.
 * 
 * Could not load the following classes:
 *  net.minecraft.client.gui.GuiDisconnected
 *  net.minecraft.client.gui.GuiDownloadTerrain
 *  net.minecraft.client.gui.GuiMainMenu
 *  net.minecraft.client.gui.GuiMultiplayer
 *  net.minecraft.entity.Entity
 *  net.minecraft.network.Packet
 *  net.minecraft.network.play.client.CPacketConfirmTeleport
 *  net.minecraft.network.play.client.CPacketPlayer
 *  net.minecraft.network.play.client.CPacketPlayer$Position
 *  net.minecraft.network.play.client.CPacketPlayer$Rotation
 *  net.minecraft.network.play.server.SPacketPlayerPosLook
 *  net.minecraft.network.play.server.SPacketPlayerPosLook$EnumFlags
 *  net.minecraft.util.math.BlockPos
 *  net.minecraft.util.math.Vec3d
 *  net.minecraftforge.fml.common.eventhandler.SubscribeEvent
 */
package cascade.features.modules.exploit;

import cascade.Cascade;
import cascade.event.events.MoveEvent;
import cascade.event.events.PacketEvent;
import cascade.event.events.PushEvent;
import cascade.event.events.UpdateWalkingPlayerEvent;
import cascade.features.modules.Module;
import cascade.features.setting.Setting;
import cascade.mixin.mixins.accessor.ISPacketPlayerPosLook;
import cascade.mixin.mixins.accessor.ITimer;
import cascade.util.misc.TimeVec3d;
import cascade.util.misc.Timer;
import cascade.util.player.MovementUtil;
import java.util.ArrayList;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import net.minecraft.client.gui.GuiDisconnected;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.client.gui.GuiMainMenu;
import net.minecraft.client.gui.GuiMultiplayer;
import net.minecraft.entity.Entity;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class Phase
extends Module {
    Setting<Type> type = this.register(new Setting<Type>("Type", Type.Fast));
    Setting<Mode> packetMode = this.register(new Setting<Mode>("PacketMode", Mode.Up));
    Setting<Boolean> strict = this.register(new Setting<Boolean>("Strict", true));
    Setting<Boolean> bounds = this.register(new Setting<Boolean>("Bounds", true));
    Setting<PhaseMode> phase = this.register(new Setting<PhaseMode>("PhaseMode", PhaseMode.NCP));
    Setting<Boolean> multiAxis = this.register(new Setting<Boolean>("MultiAxis", false));
    Setting<Boolean> noPhaseSlow = this.register(new Setting<Boolean>("NoPhaseSlow", false));
    Setting<Float> speed = this.register(new Setting<Float>("Speed", Float.valueOf(1.0f), Float.valueOf(0.1f), Float.valueOf(3.5f)));
    Setting<Float> factor = this.register(new Setting<Object>("Factor", Float.valueOf(1.0f), Float.valueOf(0.1f), Float.valueOf(10.0f), v -> this.type.getValue() == Type.Factor || this.type.getValue() == Type.DeSync));
    Setting<AntiKick> antiKickMode = this.register(new Setting<AntiKick>("AntiKick", AntiKick.Normal));
    Setting<Limit> limit = this.register(new Setting<Limit>("Limit", Limit.None));
    Setting<Boolean> constrict = this.register(new Setting<Boolean>("Constrict", false));
    Setting<Boolean> jitter = this.register(new Setting<Boolean>("Jitter", false));
    Setting<Boolean> boost = this.register(new Setting<Boolean>("Boost", false));
    Setting<Boolean> facrotize = this.register(new Setting<Object>("SnapOnSneak", Boolean.valueOf(true), v -> this.type.getValue() == Type.Factor));
    Setting<Float> motion = this.register(new Setting<Object>("Distance", Float.valueOf(5.0f), Float.valueOf(0.1f), Float.valueOf(20.0f), v -> this.type.getValue() == Type.Factor));
    Map<Integer, TimeVec3d> posLooks = new ConcurrentHashMap<Integer, TimeVec3d>();
    ArrayList<CPacketPlayer> packets = new ArrayList();
    CPacketPlayer.Position startingOutOfBoundsPos;
    Timer intervalTimer = new Timer();
    Random random = new Random();
    boolean limitStrict = false;
    boolean oddJitter = false;
    float postPitch = -400.0f;
    int factorCounter = 0;
    int antiKickTicks = 0;
    float postYaw = -400.0f;
    int jitterTicks = 0;
    int limitTicks = 0;
    double speedX = 0.0;
    double speedY = 0.0;
    double speedZ = 0.0;
    int vDelay = 0;
    int hDelay = 0;
    int teleportId;

    public Phase() {
        super("Phase", Module.Category.EXPLOIT, "pigstep");
    }

    @Override
    public void onUpdate() {
        if (Phase.fullNullCheck()) {
            return;
        }
        if (Phase.mc.currentScreen instanceof GuiDisconnected || Phase.mc.currentScreen instanceof GuiMainMenu || Phase.mc.currentScreen instanceof GuiMultiplayer || Phase.mc.currentScreen instanceof GuiDownloadTerrain) {
            this.disable();
            return;
        }
        if (this.boost.getValue().booleanValue()) {
            Cascade.timerManager.set(1.0888f);
        }
        if (!this.boost.getValue().booleanValue() && ((ITimer)Phase.mc.timer).getTickLength() != 50.0f) {
            Cascade.timerManager.reset();
        }
    }

    @SubscribeEvent
    public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent e) {
        if (this.isDisabled()) {
            return;
        }
        if (Phase.mc.thePlayer.ticksExisted % 20 == 0) {
            this.cleanPosLooks();
        }
        Phase.mc.thePlayer.setVelocity(0.0, 0.0, 0.0);
        if (this.teleportId <= 0 && this.type.getValue() != Type.SetBack) {
            this.startingOutOfBoundsPos = new CPacketPlayer.Position(this.randomHorizontal(), 1.0, this.randomHorizontal(), Phase.mc.thePlayer.onGround);
            this.packets.add((CPacketPlayer)this.startingOutOfBoundsPos);
            mc.getNetHandler().addToSendQueue((Packet)this.startingOutOfBoundsPos);
            return;
        }
        boolean phasing = this.checkCollisionBox();
        this.speedX = 0.0;
        this.speedY = 0.0;
        this.speedZ = 0.0;
        if (Phase.mc.gameSettings.keyBindJump.getIsKeyPressed() && (this.hDelay < 1 || this.multiAxis.getValue().booleanValue() && phasing)) {
            this.speedY = Phase.mc.thePlayer.ticksExisted % (this.type.getValue() == Type.SetBack || this.type.getValue() == Type.Slow || this.limit.getValue() == Limit.Strict ? 10 : 20) == 0 ? (this.antiKickMode.getValue() != AntiKick.None ? -0.032 : 0.062) : 0.062;
            this.antiKickTicks = 0;
            this.vDelay = 5;
        } else if (Phase.mc.gameSettings.keyBindSneak.getIsKeyPressed() && (this.hDelay < 1 || this.multiAxis.getValue().booleanValue() && phasing)) {
            this.speedY = -0.062;
            this.antiKickTicks = 0;
            this.vDelay = 5;
        }
        if (this.multiAxis.getValue().booleanValue() && phasing || !Phase.mc.gameSettings.keyBindSneak.getIsKeyPressed() || !Phase.mc.gameSettings.keyBindJump.getIsKeyPressed()) {
            if (MovementUtil.isMoving()) {
                double[] dir = MovementUtil.forward((phasing && this.phase.getValue() == PhaseMode.NCP ? (this.noPhaseSlow.getValue().booleanValue() ? (this.multiAxis.getValue().booleanValue() ? 0.0465 : 0.062) : 0.031) : 0.26) * (double)this.speed.getValue().floatValue());
                if ((dir[0] != 0.0 || dir[1] != 0.0) && (this.vDelay < 1 || this.multiAxis.getValue().booleanValue() && phasing)) {
                    this.speedX = dir[0];
                    this.speedZ = dir[1];
                    this.hDelay = 5;
                }
            }
            if (this.antiKickMode.getValue() != AntiKick.None && (this.limit.getValue() == Limit.None || this.limitTicks != 0)) {
                if (this.antiKickTicks < (this.packetMode.getValue() == Mode.Bypass && this.bounds.getValue() == false ? 1 : 3)) {
                    ++this.antiKickTicks;
                } else {
                    this.antiKickTicks = 0;
                    if (this.antiKickMode.getValue() != AntiKick.Limited || !phasing) {
                        double d = this.speedY = this.antiKickMode.getValue() == AntiKick.Strict ? -0.08 : -0.04;
                    }
                }
            }
        }
        if (phasing && (this.phase.getValue() == PhaseMode.NCP && (double)Phase.mc.thePlayer.moveForward != 0.0 || (double)Phase.mc.thePlayer.moveStrafing != 0.0 && this.speedY != 0.0)) {
            this.speedY /= 2.5;
        }
        if (this.limit.getValue() != Limit.None) {
            if (this.limitTicks == 0) {
                this.speedX = 0.0;
                this.speedY = 0.0;
                this.speedZ = 0.0;
            } else if (this.limitTicks == 2 && this.jitter.getValue().booleanValue()) {
                if (this.oddJitter) {
                    this.speedX = 0.0;
                    this.speedY = 0.0;
                    this.speedZ = 0.0;
                }
                this.oddJitter = !this.oddJitter;
            }
        } else if (this.jitter.getValue().booleanValue() && this.jitterTicks == 7) {
            this.speedX = 0.0;
            this.speedY = 0.0;
            this.speedZ = 0.0;
        }
        switch (this.type.getValue()) {
            case Fast: {
                Phase.mc.thePlayer.setVelocity(this.speedX, this.speedY, this.speedZ);
                this.sendPackets(this.speedX, this.speedY, this.speedZ, this.packetMode.getValue(), true, false);
                break;
            }
            case Slow: {
                this.sendPackets(this.speedX, this.speedY, this.speedZ, this.packetMode.getValue(), true, false);
                break;
            }
            case SetBack: {
                Phase.mc.thePlayer.setVelocity(this.speedX, this.speedY, this.speedZ);
                this.sendPackets(this.speedX, this.speedY, this.speedZ, this.packetMode.getValue(), false, false);
                break;
            }
            case Factor: 
            case DeSync: {
                float rawFactor = this.factor.getValue().floatValue();
                if (this.facrotize.getValue().booleanValue() && Phase.mc.gameSettings.keyBindSneak.getIsKeyPressed() && this.intervalTimer.passedMs(3500L)) {
                    this.intervalTimer.reset();
                    rawFactor = this.motion.getValue().floatValue();
                }
                int factorInt = (int)Math.floor(rawFactor);
                ++this.factorCounter;
                if (this.factorCounter > (int)(20.0 / (((double)rawFactor - (double)factorInt) * 20.0))) {
                    ++factorInt;
                    this.factorCounter = 0;
                }
                for (int i = 1; i <= factorInt; ++i) {
                    Phase.mc.thePlayer.setVelocity(this.speedX * (double)i, this.speedY * (double)i, this.speedZ * (double)i);
                    this.sendPackets(this.speedX * (double)i, this.speedY * (double)i, this.speedZ * (double)i, this.packetMode.getValue(), true, false);
                }
                this.speedX = Phase.mc.thePlayer.motionX;
                this.speedY = Phase.mc.thePlayer.motionY;
                this.speedZ = Phase.mc.thePlayer.motionZ;
            }
        }
        --this.vDelay;
        --this.hDelay;
        if (this.constrict.getValue().booleanValue() && (this.limit.getValue() == Limit.None || this.limitTicks > 1)) {
            mc.getNetHandler().addToSendQueue((Packet)new CPacketPlayer.Position(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ, false));
        }
        ++this.limitTicks;
        ++this.jitterTicks;
        if (this.limitTicks > (this.limit.getValue() == Limit.Strict ? (this.limitStrict ? 1 : 2) : 3)) {
            this.limitTicks = 0;
            boolean bl = this.limitStrict = !this.limitStrict;
        }
        if (this.jitterTicks > 7) {
            this.jitterTicks = 0;
        }
    }

    private void sendPackets(double x, double y, double z, Mode mode, boolean sendConfirmTeleport, boolean sendExtraCT) {
        Vec3d nextPos = new Vec3d(Phase.mc.thePlayer.posX + x, Phase.mc.thePlayer.posY + y, Phase.mc.thePlayer.posZ + z);
        Vec3d bounds = this.getBoundsVec(x, y, z, mode);
        CPacketPlayer.Position nextPosPacket = new CPacketPlayer.Position(nextPos.xCoord, nextPos.yCoord, nextPos.zCoord, Phase.mc.thePlayer.onGround);
        this.packets.add((CPacketPlayer)nextPosPacket);
        mc.getNetHandler().addToSendQueue((Packet)nextPosPacket);
        if (this.limit.getValue() != Limit.None && this.limitTicks == 0) {
            return;
        }
        CPacketPlayer.Position boundsPacket = new CPacketPlayer.Position(bounds.xCoord, bounds.yCoord, bounds.zCoord, Phase.mc.thePlayer.onGround);
        this.packets.add((CPacketPlayer)boundsPacket);
        mc.getNetHandler().addToSendQueue((Packet)boundsPacket);
        if (sendConfirmTeleport) {
            ++this.teleportId;
            if (sendExtraCT) {
                mc.getNetHandler().addToSendQueue((Packet)new CPacketConfirmTeleport(this.teleportId - 1));
            }
            mc.getNetHandler().addToSendQueue((Packet)new CPacketConfirmTeleport(this.teleportId));
            this.posLooks.put(this.teleportId, new TimeVec3d(nextPos.xCoord, nextPos.yCoord, nextPos.zCoord, System.currentTimeMillis()));
            if (sendExtraCT) {
                mc.getNetHandler().addToSendQueue((Packet)new CPacketConfirmTeleport(this.teleportId + 1));
            }
        }
    }

    Vec3d getBoundsVec(double x, double y, double z, Mode mode) {
        switch (mode) {
            case Up: {
                return new Vec3d(Phase.mc.thePlayer.posX + x, this.bounds.getValue() != false ? (double)(this.strict.getValue() != false ? 255 : 256) : Phase.mc.thePlayer.posY + 420.0, Phase.mc.thePlayer.posZ + z);
            }
            case Preserve: {
                return new Vec3d(this.bounds.getValue() != false ? Phase.mc.thePlayer.posX + this.randomHorizontal() : this.randomHorizontal(), this.strict.getValue() != false ? Math.max(Phase.mc.thePlayer.posY, 2.0) : Phase.mc.thePlayer.posY, this.bounds.getValue() != false ? Phase.mc.thePlayer.posZ + this.randomHorizontal() : this.randomHorizontal());
            }
            case LimitJitter: {
                return new Vec3d(Phase.mc.thePlayer.posX + (this.strict.getValue() != false ? x : this.randomLimitedHorizontal()), Phase.mc.thePlayer.posY + this.randomLimitedVertical(), Phase.mc.thePlayer.posZ + (this.strict.getValue() != false ? z : this.randomLimitedHorizontal()));
            }
            case Bypass: {
                if (this.bounds.getValue().booleanValue()) {
                    double rawY = y * 510.0;
                    return new Vec3d(Phase.mc.thePlayer.posX + x, Phase.mc.thePlayer.posY + (rawY > (double)(Phase.mc.thePlayer.dimension == -1 ? 127 : 255) ? -rawY : (rawY < 1.0 ? -rawY : rawY)), Phase.mc.thePlayer.posZ + z);
                }
                return new Vec3d(Phase.mc.thePlayer.posX + (x == 0.0 ? (double)(this.random.nextBoolean() ? -10 : 10) : x * 38.0), Phase.mc.thePlayer.posY + y, Phase.mc.thePlayer.posX + (z == 0.0 ? (double)(this.random.nextBoolean() ? -10 : 10) : z * 38.0));
            }
            case Obscure: {
                return new Vec3d(Phase.mc.thePlayer.posX + this.randomHorizontal(), Math.max(1.5, Math.min(Phase.mc.thePlayer.posY + y, 253.5)), Phase.mc.thePlayer.posZ + this.randomHorizontal());
            }
        }
        return new Vec3d(Phase.mc.thePlayer.posX + x, this.bounds.getValue() != false ? (double)(this.strict.getValue() != false ? 1 : 0) : Phase.mc.thePlayer.posY - 1337.0, Phase.mc.thePlayer.posZ + z);
    }

    double randomHorizontal() {
        int randomValue = this.random.nextInt(this.bounds.getValue().booleanValue() ? 80 : (this.packetMode.getValue() == Mode.Obscure ? (Phase.mc.thePlayer.ticksExisted % 2 == 0 ? 480 : 100) : 29000000)) + (this.bounds.getValue() != false ? 5 : 500);
        if (this.random.nextBoolean()) {
            return randomValue;
        }
        return -randomValue;
    }

    double randomLimitedVertical() {
        int randomValue = this.random.nextInt(22);
        randomValue += 70;
        if (this.random.nextBoolean()) {
            return randomValue;
        }
        return -randomValue;
    }

    double randomLimitedHorizontal() {
        int randomValue = this.random.nextInt(10);
        if (this.random.nextBoolean()) {
            return randomValue;
        }
        return -randomValue;
    }

    void cleanPosLooks() {
        this.posLooks.forEach((tp, timeVec3d) -> {
            if (System.currentTimeMillis() - timeVec3d.getTime() > TimeUnit.SECONDS.toMillis(30L)) {
                this.posLooks.remove(tp);
            }
        });
    }

    @Override
    public void onEnable() {
        if (Phase.fullNullCheck()) {
            return;
        }
        this.packets.clear();
        this.posLooks.clear();
        this.teleportId = 0;
        this.vDelay = 0;
        this.hDelay = 0;
        this.postYaw = -400.0f;
        this.postPitch = -400.0f;
        this.antiKickTicks = 0;
        this.limitTicks = 0;
        this.jitterTicks = 0;
        this.speedX = 0.0;
        this.speedY = 0.0;
        this.speedZ = 0.0;
        this.oddJitter = false;
        this.startingOutOfBoundsPos = null;
        this.startingOutOfBoundsPos = new CPacketPlayer.Position(this.randomHorizontal(), 1.0, this.randomHorizontal(), Phase.mc.thePlayer.onGround);
        this.packets.add((CPacketPlayer)this.startingOutOfBoundsPos);
        mc.getNetHandler().addToSendQueue((Packet)this.startingOutOfBoundsPos);
    }

    @Override
    public void onDisable() {
        if (Phase.fullNullCheck()) {
            return;
        }
        Phase.mc.thePlayer.setVelocity(0.0, 0.0, 0.0);
        if (((ITimer)Phase.mc.timer).getTickLength() != 50.0f) {
            Cascade.timerManager.reset();
        }
    }

    @SubscribeEvent
    public void onReceive(PacketEvent.Receive e) {
        if (this.isDisabled() || Phase.fullNullCheck()) {
            return;
        }
        if (e.getPacket() instanceof SPacketPlayerPosLook) {
            if (!(Phase.mc.currentScreen instanceof GuiDownloadTerrain)) {
                SPacketPlayerPosLook packet = (SPacketPlayerPosLook)e.getPacket();
                if (Phase.mc.thePlayer.isEntityAlive()) {
                    if (this.teleportId <= 0) {
                        this.teleportId = ((SPacketPlayerPosLook)e.getPacket()).getTeleportId();
                    } else if (Phase.mc.theWorld.isBlockLoaded(new BlockPos(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ), false) && this.type.getValue() != Type.SetBack) {
                        if (this.type.getValue() == Type.DeSync) {
                            this.posLooks.remove(packet.getTeleportId());
                            e.setCanceled(true);
                            if (this.type.getValue() == Type.Slow) {
                                Phase.mc.thePlayer.setPosition(packet.getX(), packet.getY(), packet.getZ());
                            }
                            return;
                        }
                        if (this.posLooks.containsKey(packet.getTeleportId())) {
                            TimeVec3d vec = this.posLooks.get(packet.getTeleportId());
                            if (vec.xCoord == packet.getX() && vec.yCoord == packet.getY() && vec.zCoord == packet.getZ()) {
                                this.posLooks.remove(packet.getTeleportId());
                                e.setCanceled(true);
                                if (this.type.getValue() == Type.Slow) {
                                    Phase.mc.thePlayer.setPosition(packet.getX(), packet.getY(), packet.getZ());
                                }
                                return;
                            }
                        }
                    }
                }
                ((ISPacketPlayerPosLook)packet).setYaw(Phase.mc.thePlayer.rotationYaw);
                ((ISPacketPlayerPosLook)packet).setPitch(Phase.mc.thePlayer.rotationPitch);
                packet.getFlags().remove(SPacketPlayerPosLook.EnumFlags.X_ROT);
                packet.getFlags().remove(SPacketPlayerPosLook.EnumFlags.Y_ROT);
                this.teleportId = packet.getTeleportId();
            } else {
                this.teleportId = 0;
            }
        }
    }

    @SubscribeEvent
    public void onMove(MoveEvent e) {
        if (this.isDisabled()) {
            return;
        }
        if (this.type.getValue() != Type.SetBack && this.teleportId <= 0) {
            return;
        }
        if (this.type.getValue() != Type.Slow) {
            e.setX(this.speedX);
            e.setY(this.speedY);
            e.setZ(this.speedZ);
        }
        if (this.phase.getValue() != PhaseMode.None && this.phase.getValue() == PhaseMode.Vanilla || this.checkCollisionBox()) {
            Phase.mc.thePlayer.noClip = true;
        }
    }

    @SubscribeEvent
    public void onPacketSend(PacketEvent.Send e) {
        if (this.isDisabled() || Phase.fullNullCheck()) {
            return;
        }
        if (e.getPacket() instanceof CPacketPlayer.Rotation) {
            e.setCanceled(true);
        }
        if (e.getPacket() instanceof CPacketPlayer) {
            CPacketPlayer packet = (CPacketPlayer)e.getPacket();
            if (this.packets.contains(packet)) {
                this.packets.remove(packet);
                return;
            }
            e.setCanceled(true);
        }
    }

    @SubscribeEvent
    public void onPush(PushEvent e) {
        if (this.isDisabled()) {
            return;
        }
        e.setCanceled(true);
    }

    boolean checkCollisionBox() {
        if (!Phase.mc.theWorld.getCollisionBoxes((Entity)Phase.mc.thePlayer, Phase.mc.thePlayer.getEntityBoundingBox().addCoord(0.0, 0.0, 0.0)).isEmpty()) {
            return true;
        }
        return !Phase.mc.theWorld.getCollisionBoxes((Entity)Phase.mc.thePlayer, Phase.mc.thePlayer.getEntityBoundingBox().offset(0.0, 2.0, 0.0).contract(0.0, 1.99, 0.0)).isEmpty();
    }

    static enum Limit {
        None,
        Strong,
        Strict;

    }

    static enum AntiKick {
        None,
        Normal,
        Limited,
        Strict;

    }

    static enum PhaseMode {
        None,
        Vanilla,
        NCP;

    }

    static enum Mode {
        Up,
        Preserve,
        Down,
        LimitJitter,
        Bypass,
        Obscure;

    }

    static enum Type {
        Factor,
        SetBack,
        Fast,
        Slow,
        DeSync;

    }
}

